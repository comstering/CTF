# basic_exploitation_002

### Problem
    #include <stdio.h>
    #include <stdlib.h>
    #include <signal.h>
    #include <unistd.h>
    
    void alarm_handler() {
        puts("TIME OUT");
        exit(-1);
    }
    
    void initialize() {
        setvbuf(stdin, NULL, _IONBF, 0);
        setvbuf(stdout, NULL, _IONBF, 0);
    
        signal(SIGALRM, alarm_handler);
        alarm(30);
    }
    
    void get_shell() {
        system("/bin/sh");
    }
    
    int main(int argc, char *argv[]) {
    
        char buf[0x80];
    
        initialize();
    
        read(0, buf, 0x80);
        printf(buf);
    
        exit(0);
    }

### Solution
1. 이번 문제는 버퍼오버플로우가 아닌 FSB 취약점을 이용한 문제다.

2. 소스코드의 printf문을 보면 서식지정자를 사용하지 않고 buf를 그냥 출력한다. 이렇게 printf문을 사용할 경우 buf에 서식지정자가 있을 경우 취약점이 발생한다.

3. 즉, 서식지정자가 서식지정자의 역할을 하게 되는 것이다.

4. 먼저 gdb를 통해서 메모리를 알아보자.

![image](https://user-images.githubusercontent.com/53170968/111795108-3eba3100-890a-11eb-8755-2799a27f99c7.png)

![image](https://user-images.githubusercontent.com/53170968/111795245-58f40f00-890a-11eb-836b-9e0ba57b0750.png)

![image](https://user-images.githubusercontent.com/53170968/111795286-614c4a00-890a-11eb-9a2f-896635520011.png)

5. 프로그램 종료가 return이 아닌 exit를 이용해서 한다. 그래서 exit가 사용하는 메모리를 확인해보자.

6. exit는 메모리 0x0804a024를 역참조하여 프로그램을 종료한다. 그렇다면 우리는 get_shell함수의 메모리 주소를 저 메모리안에 넣으면 된다는 것이다.

7. get_shell의 메모리도 확인해보자.

![image](https://user-images.githubusercontent.com/53170968/111795653-c0aa5a00-890a-11eb-9e6e-8aa80faff842.png)

8. get_shell의 주소도 획득했다. 이제 문제를 풀어보자.

9. FSB 취약점을 이용해서 페이로드를 만들어 보자.

10. "\x24\xa0\x04\x08" + "%{}x".format(0x8048609 - 0x4) + "%n"

![image](https://user-images.githubusercontent.com/53170968/111793314-7d4eec00-8908-11eb-9cc1-f47e627aee4e.png)

11. 제대로된 페이로드를 사용했는데 TIME OUT이 뜨면서 종료됬다.

12. 그 이유가 메모리 주소값으로 들어가는 문자열의 개수를 봤더니 엄청난 결과가 나왔다.

![image](https://user-images.githubusercontent.com/53170968/111793905-12ea7b80-8909-11eb-97e0-189322c6a1cb.png)

13. 1억이 넘어가는 출력문이 나왔다. 이러니 당연히 TIME OUT이 나올 수 밖에 없었다.

14. 그래서 메모리 주소를 2Byte단위로 따로따로 넣기로 했다.

15. "\x26\xa0\x04\x08" + "\x24\xa0\x04\x08" + "%{}x".format(0x804 - 0x8) + "%1$hn" + "%{}x".format(0x8609 - 0x804) + "%2$hn"

16. 페이로드를 다시 작성하고 다시 실행해보자.

![image](https://user-images.githubusercontent.com/53170968/111795998-1121b780-890b-11eb-9eee-d5ebc5d8811c.png)

17. TIME OUT이 뜨지 않았다 잘 실행된 것 같다. 제대로 실행됬다면 쉘권한을 얻은 것이니 간단한 명령어를 입력해보자.

![image](https://user-images.githubusercontent.com/53170968/111796167-3f06fc00-890b-11eb-98d0-80dbab9189d6.png)

18. 쉘권한을 제대로 얻었다. 그렇다면 DreamHack 서버에 접속해서 FLAG를 얻어보자.

![image](https://user-images.githubusercontent.com/53170968/111796273-5d6cf780-890b-11eb-943e-f90bb7e63b4e.png)

19. 접속 정보를 먼저 얻은 다음 서버로 실행했다.

![image](https://user-images.githubusercontent.com/53170968/111796331-6c53aa00-890b-11eb-9e3c-b5531e64c76e.png)

20. 정상적으로 취약점을 공격하고 쉘권한을 얻은 것을 볼 수 있다. 그렇다면 FLAG를 획득해보자.

![image](https://user-images.githubusercontent.com/53170968/111796503-960cd100-890b-11eb-8f10-c33b82d5cc2f.png)

21. 이제 획득한 FLAG를 제출하자.

![image](https://user-images.githubusercontent.com/53170968/111796597-aa50ce00-890b-11eb-99e2-81c7da2838a3.png)

![image](https://user-images.githubusercontent.com/53170968/111796610-ade45500-890b-11eb-82d2-4f1b9c85b23d.png)
