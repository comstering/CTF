# basic_exploitation_000

### Problem
    #include <stdio.h>
    #include <stdlib.h>
    #include <signal.h>
    #include <unistd.h>
    
    void alarm_handler() {
        puts("TIME OUT");
        exit(-1);
    }
    
    void initialize() {
        setvbuf(stdin, NULL, _IONBF, 0);
        setvbuf(stdout, NULL, _IONBF, 0);
    
        signal(SIGALRM, alarm_handler);
        alarm(30);
    }
    
    int main(int argc, char *argv[]) {
    
        char buf[0x80];
    
        initialize();
        
        printf("buf = (%p)\n", buf);
        scanf("%141s", buf);
    
        return 0;
    }

### Solution
1. 소스코드를 먼저 분석하자.

2. buf란 문자 배열변수가 있고 크기는 0x80 = 128이다.

3. 그리고 initialize()함수가 호출된다.

4. initialize()함수는 제한시간을 두는 함수인 것 같다. 30초 안에 모든 것을 해결해야하나보다.

5. printf로 buf의 주소값을 출력해주고 scanf로 사용자입력을 받는다. 이때 입력을 141개의 문자까지 받도록 되어있다.

6. 그리고 프로그램이 종료된다.

7. 프로그램을 먼저 컴파일해서 실행시켜보자.

![image](https://user-images.githubusercontent.com/53170968/111673821-b5015980-885e-11eb-9f98-c6569a693cfd.png)

8. buf의 메모리주소을 알려주고 입력을 받으면 종료, 30초가 지나면 TIME OUT을 출력하고 종료가 된다.

9. 이 문제는 버퍼오버플로우를 이용한 문제이다. 그리고 쉘코드를 이용해서 쉘의 권한을 얻는 것이 목적이다.

10. 먼저 메모리 중 Stack영역의 구조를 알아보자.

![image](https://user-images.githubusercontent.com/53170968/111673462-5805a380-885e-11eb-9141-1cb9142bdfb5.png)

11. Stack메모리 구조는 위와 같을 것이다. main함수에서 선언한 지역변수인 buf가 있고 sfp, ret 등이 메모리에 쌓여있다.

12. 여기서 sfp는 메모리주소가 들어가는 포인터공간이라고 알고 있으면 되고 ret는 return에 해당하는 메모리라고 생각하면 된다.

13. 버퍼오버플로우는 정해져있는 메모리를 넘어선 데이터가 입력되는 것을 말한다. 예를 들어 30크기의 메모리에 35크기의 데이터가 입력된다면 5크기가 넘어(오버)가게 된다. 이것을 오버플로우라고 하는 것이다.

14. 넘어간 데이터는 그냥 사라질까? 아니다 넘어간 데이터는 기존 메모리 다음 메모리공간을 차지하게 된다. 즉, 우리가 buf에 값을 넘치게 담게 되면 buf의 메모리를 넘어서고 sfp 더 나아가 ret의 메모리 영역까지 데이터가 침범하게 되는 것이다.

15. ret가 무엇이라고 했는가? return에 해당하는 메모리공간이라고 했다. ret에는 return이 될 경우 이동할 메모리 공간의 주소가 들어간다. 그렇다면 우리는 ret에 저장되어있는 메모리 주소값을 조작해서 내가 원하는 메모리 공간으로 이동시켜야한다.

16. 그 공간이 어디일까? 우리가 알 수 있는 메모리 주소는 오직 buf의 메모리 주소밖에 없다. 또한 우리는 쉘코드를 통해서 쉘의 권한도 얻어야 한다.

17. 그렇다면 결론이 나오게 된다. buf에 쉘코드가 저장되어 있고 ret의 메모리 공간에 buf의 메모리주소를 넣어 return에 buf로 향하게 한다면 쉘코드가 실행될 것이다.

![image](https://user-images.githubusercontent.com/53170968/111675158-2ab9f500-8860-11eb-8fd2-923522411277.png)


18. 그렇다면 buf에 입력되어야 할 값은 쉘코드 + sfp 공간을 넘어가는 데이터 + buf의 메모리 주소다.

19. buf의 크기는 128Byte, sfp의 크기는 32bit일 경우 4Byte, 64bit일 경우 8Byte이다.

20. 그렇다면 buf에 입력해야할 데이터의 크기는 128 + (4 or 8) = 132 or 136 이다.

21. 그리고 쉘코드는 26Byte의 쉘코드를 사용할 것이다.

22. '\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x31\xc9\x31\xd2\xb0\x08\x40\x40\x40\xcd\x80'

23. 해당 쉘코드는 32Bit에서 사용가능한 쉘코드로 64bit에서는 사용할 수 없다.

24. DreamHack 사이트에서 접속서버를 획득하자.

![image](https://user-images.githubusercontent.com/53170968/111675743-cb101980-8860-11eb-9f54-d97c11f0eb84.png)

25. pwntools를 통해서 접속을 하자. 코드는 따로 첨부

![image](https://user-images.githubusercontent.com/53170968/111675899-f98df480-8860-11eb-9220-ed20a04e48d3.png)

26. 쉘코드를 잘 사용했다면 쉘 권한을 얻고 FLAG를 확인할 수 있을 것이다.

![image](https://user-images.githubusercontent.com/53170968/111676040-19251d00-8861-11eb-994e-f29d38b4f35c.png)

![image](https://user-images.githubusercontent.com/53170968/111676052-1c200d80-8861-11eb-9ff9-e75bb227e7e1.png)

27. FLAG를 입력해서 정답으로 통과되었다.